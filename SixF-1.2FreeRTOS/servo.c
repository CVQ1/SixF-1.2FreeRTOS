#include <math.h>
#include "os_Task.h"
#include "servo.h"
#include "PCA_H_I2C_HAL.h"

const uint16_t stand[18] = { 240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318 };
const uint16_t test[7][18] = {
	{ 155, 420, 297, 350, 380, 290, 251, 358, 344, 307, 307, 307, 307, 307, 307, 307, 307, 307 },
    {155, 440, 290, 325, 410, 280, 165, 410, 361, 200, 200, 200, 200, 200, 200, 200, 200, 200, },
	{240, 398, 307, 310, 407, 293, 196, 395, 350, 200, 200, 200, 200, 200, 200, 200, 200, 200, },
	{251, 398, 309, 300, 399, 307, 213, 388, 329, 200, 200, 200, 200, 200, 200, 200, 200, 200, },
	{285, 395, 322, 268, 403, 316, 230, 380, 315, 200, 200, 200, 200, 200, 200, 200, 200, 200, },
	{305,399, 336, 240, 410, 325, 240, 377, 307, 200, 200, 200, 200, 200, 200, 200, 200, 200, },
	{350, 360, 320, 240, 410, 325, 240, 377, 307, 200, 200, 200, 200, 200, 200, 200, 200, 200, }
};
const uint16_t down[18] = { 310, 360, 325, 270, 365, 315, 290, 355, 307, 282, 290, 304, 295, 330, 307, 310, 275, 318 };

const uint16_t Forward[26][18] = {
//     1					  2						  3						4						5					   6			
	{  350, 370, 290, 205, 412, 315, 155, 420, 297, 240, 330, 304, 251, 358, 344, 378, 235, 318 },  // A:抬前  B:定原 -------启动部分           0
	{  325, 410, 280, 205, 412, 315, 155, 440, 297, 240, 330, 304, 165, 410, 361, 378, 235, 318 }, // A:落前  B:定原                                     1
	
	{  310, 407, 293, 240, 380, 280, 240, 398, 307, 215, 317, 304, 196, 395, 350, 280, 270, 340 }, // A:蹬1	B:抬前									  2
	{  300, 399, 307, 240, 380, 280, 251, 398, 309, 215, 317, 304, 213, 388, 329, 280, 270, 340 },  // A:蹬2	B:抬前									  3
	{  268, 403, 316, 240, 380, 280, 285, 395, 322, 215, 317, 304, 230, 380, 315, 280, 270, 340 },  // A:蹬3	B:抬前
	{  240, 410, 325, 168, 430, 260, 305, 399, 336, 240, 330, 304, 240, 377, 307, 295, 232, 375 },  // A:蹬4	B:落前 --------A后B前  
	
	{  350, 370, 290, 185, 425, 275, 310, 340, 307, 260, 330, 296, 280, 330, 344, 305, 235, 355 },   // A:抬后  B:蹬1--------A后B前			  6
	{  350, 370, 290, 200, 416, 288, 310, 340, 307, 283, 325, 290, 280, 330, 344, 317, 240, 338 },  // A:抬后  B:蹬2
	{  350, 370, 290, 210, 410, 300, 310, 340, 307, 297, 330, 280, 280, 330, 344, 340, 240, 327 },  // A:抬后  B:蹬3
	{  325, 410, 280, 205, 412, 315, 155, 440, 297, 325, 330, 263, 165, 410, 361, 378, 235, 318 },  // A:落前  B:蹬4 --------A前B后
	
	{  310, 407, 293, 240, 380, 280, 240, 398, 307, 330, 260, 285, 196, 395, 350, 280, 270, 340 },  // A:蹬1	B:抬后 --------A前B后			  10
	{  300, 399, 307, 240, 380, 280, 251, 398, 309, 330, 260, 285, 213, 388, 329, 280, 270, 340 },  // A:蹬2	B:抬后
	{  268, 403, 316, 240, 380, 280, 285, 395, 322, 330, 260, 285, 230, 380, 315, 280, 270, 340 },  // A:蹬3	B:抬后
	{  240, 410, 325, 168, 430, 260, 305, 399, 336, 240, 330, 304, 240, 377, 307, 295, 232, 375 },  // A:蹬4	B:落前 --------A后B前  
	
	{  310, 360, 325, 185, 425, 275, 310, 340, 307, 260, 330, 296, 295, 330, 307, 305, 235, 355 },  // A:3抬后,余抬原  B:蹬1--------A后B前  14
	{  310, 360, 325, 200, 416, 288, 310, 340, 307, 283, 325, 290, 295, 330, 307, 317, 240, 338 },  // A:3抬后,余抬原  B:蹬2
	{  310, 360, 325, 210, 410, 300, 310, 340, 307, 297, 330, 280, 295, 330, 307, 340, 240, 327 },  // A:3抬后,余抬原  B:蹬3
	{  240, 410, 325, 205, 412, 315, 240, 398, 307, 325, 330, 263, 240, 377, 307, 378, 235, 318 },  // A:落原				  B:蹬4 --------除3外全归原
	
	{ 240, 410, 325, 205, 412, 315, 240, 398, 307, 330, 260, 285, 240, 377, 307, 378, 235, 318 },    // A:定	B:4抬后									   18
	{ 240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318 },    // A:定	B:4落原
	
	{  310, 407, 293, 270, 365, 315, 240, 398, 307, 330, 260, 285, 196, 395, 350, 310, 275, 318 },  // A:蹬1	B:4抬后,余抬原 --------A前B后 20
	{  300, 399, 307, 270, 365, 315, 251, 398, 309, 330, 260, 285, 213, 388, 329, 310, 275, 318 },  // A:蹬2	B:4抬后,余抬原
	{  268, 403, 316, 270, 365, 315, 285, 395, 322, 330, 260, 285, 230, 380, 315, 310, 275, 318 },  // A:蹬3	B:4抬后,余抬原
	{  240, 410, 325, 205, 412, 315, 305, 399, 336, 240, 330, 304, 240, 377, 307, 378, 235, 318 },  // A:蹬4	B:落原 --------除4外全归原
	
	{  240, 410, 325, 205, 412, 315, 310, 340, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318 },  // A:3抬后	B:定										24
	{  240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318 }   // A:3落原	B:定
	
};


const uint16_t Turnright[11][18] = {
		
	 //  310, 360, 325, 270, 365, 315, 290, 355, 307, 282, 290, 304, 295, 330, 307, 310, 275, 318         抬
	 //  240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318         原
	
	//  240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318          0
	//  310, 360, 335, 270, 365, 325, 290, 355, 317, 282, 290, 314, 295, 330, 317, 310, 275, 328          1
	//  310, 360, 345, 270, 365, 335, 290, 355, 327, 282, 290, 324, 295, 330, 327, 310, 275, 338          2
	//  240, 410, 355, 205, 412, 345, 240, 398, 337, 240, 330, 334, 240, 377, 337, 378, 235, 348          3
	//  240, 410, 295, 205, 412, 285, 240, 398, 277, 240, 330, 274, 240, 377, 277, 378, 235, 288          4
	//  310, 360, 305, 270, 365, 295, 290, 355, 287, 282, 290, 284, 295, 330, 287, 310, 275, 298          5
	//  310, 360, 315, 270, 365, 305, 290, 355, 297, 282, 290, 294, 295, 330, 297, 310, 275, 308          6
	
		
	//     1					  2						  3						4						5					   6			
		{ 310, 360, 335, 205, 412, 315, 290, 355, 317, 240, 330, 304, 295, 330, 317, 378, 235, 318 },    // A:1     B:0 -------启动部分           0

		{ 310, 360, 345, 205, 412, 285, 290, 355, 327, 240, 330, 274, 295, 330, 327, 378, 235, 288 },	   // A:2    B:4 -------循环部分            1
		{ 240, 410, 355, 205, 412, 285, 240, 398, 337, 240, 330, 274, 240, 377, 337, 378, 235, 288 },	   // A:3	    B:4									 2
		{ 240, 410, 355, 240, 380, 280, 240, 398, 337, 215, 317, 304, 240, 377, 337, 280, 270, 340 },	   // A:3	    B:5			------			     3
		{ 240, 410, 295, 270, 365, 335, 240, 398, 277, 282, 290, 324, 240, 377, 277, 310, 275, 338 },	   // A:4 	B:2
		{ 240, 410, 295, 205, 412, 345, 240, 398, 277, 240, 330, 334, 240, 377, 277, 378, 235, 348 }, 	   // A:4 	B:3   
		{ 310, 360, 305, 205, 412, 345, 290, 355, 297, 240, 330, 334, 295, 330, 287, 378, 235, 348 },	   // A:5    B:3			-------				 6
	
		{ 240, 410, 325, 270, 365, 305, 240, 398, 307, 282, 290, 294, 240, 377, 307, 310, 275, 308 }, 	   // A:0 	B:6									7
		{ 240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318 },	   // A:0    B:0
	
		{ 310, 360, 315, 205, 412, 315, 290, 355, 297, 240, 330, 304, 295, 330, 297, 378, 235, 318 }, 	   // A:6 	B:0									9
		{ 240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318 },	   // A:0    B:0
	
};

const uint16_t Turnleft[11][18] = {
		
	//  310, 360, 325, 270, 365, 315, 290, 355, 307, 282, 290, 304, 295, 330, 307, 310, 275, 318         抬
	//  240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318         原
	
   //  240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318          0
   //  310, 360, 335, 270, 365, 325, 290, 355, 317, 282, 290, 314, 295, 330, 317, 310, 275, 328          1
   //  310, 360, 345, 270, 365, 335, 290, 355, 327, 282, 290, 324, 295, 330, 327, 310, 275, 338          2
   //  240, 410, 355, 205, 412, 345, 240, 398, 337, 240, 330, 334, 240, 377, 337, 378, 235, 348          3
   //  240, 410, 295, 205, 412, 285, 240, 398, 277, 240, 330, 274, 240, 377, 277, 378, 235, 288          4
   //  310, 360, 305, 270, 365, 295, 290, 355, 287, 282, 290, 284, 295, 330, 287, 310, 275, 298          5
   //  310, 360, 315, 270, 365, 305, 290, 355, 297, 282, 290, 294, 295, 330, 297, 310, 275, 308          6
	
		
//     1					  2						  3						4						5					   6			
   	{ 310, 360, 315, 205, 412, 315, 290, 355, 297, 240, 330, 304, 295, 330, 297, 378, 235, 318 },	     // A:6     B:0 -------启动部分           0

   	{ 310, 360, 305, 205, 412, 345, 290, 355, 287, 240, 330, 334, 295, 330, 287, 378, 235, 348 },	 	   // A:5    B:3 -------循环部分            1
   	{ 240, 410, 295, 205, 412, 345, 240, 398, 277, 240, 330, 334, 240, 377, 277, 378, 235, 348 },	 	   // A:4	    B:3									 2
   	{ 240, 410, 295, 270, 365, 335, 240, 398, 277, 282, 290, 324, 240, 377, 277, 310, 275, 338 }, 		   // A:4	    B:2			------			     3
   	{ 240, 410, 355, 270, 365, 295, 240, 398, 337, 282, 290, 284, 240, 377, 337, 310, 275, 298 },	 	   // A:3 	B:5
   	{ 240, 410, 355, 205, 412, 285, 240, 398, 337, 240, 330, 274, 240, 377, 337, 378, 235, 288 }, 	 	   // A:3 	B:4   
   	{ 310, 360, 345, 205, 412, 285, 290, 355, 327, 240, 330, 274, 295, 330, 327, 378, 235, 288 },	 	   // A:2    B:4			-------				 6
	
   	{ 240, 410, 325, 270, 365, 325, 240, 398, 307, 282, 290, 314, 240, 377, 307, 310, 275, 328 },	  	   // A:0 	B:1									7
   	{ 240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318 },	 	   // A:0    B:0
	
   	{ 310, 360, 335, 205, 412, 315, 290, 355, 317, 240, 330, 304, 295, 330, 317, 378, 235, 318 },	  	   // A:1 	B:0									9
   	{ 240, 410, 325, 205, 412, 315, 240, 398, 307, 240, 330, 304, 240, 377, 307, 378, 235, 318 }, 		   // A:0    B:0
	
};

	

uint16_t pwm[18], tarpwm[18],lpwm[18],ltarpwm[18]; //pwm值 0--4096  int
float incpwm[18];
struct 
{
	uint8_t countflag;  //细分完成标志   0(完成) 1--20
	uint8_t modeflag;  //运动模式标志   A B C D
	uint8_t tarmodeflag;//目标运动模式
	uint8_t stepflag;    //步骤执行记录    0 1 2 3 4 5
}pwmflag;

void Robot_Stand(void)  //站立--------------A
{
	uint8_t i;
	for (i = 0; i < 18; i++)
	{
		tarpwm[i] = stand[i];
	}
	pwmflag.stepflag = 1;
}
void Robot_Down(void)  //蹲--------------C
{
	uint8_t i;
	for (i = 0; i < 18; i++)
	{
		tarpwm[i] = down[i];
	}
	pwmflag.stepflag = 0;
}
void Robot_Test(void) //---------------B
{
	uint8_t i;
	
	for (i = 0; i < 18; i++)
	{
		tarpwm[i] = test[pwmflag.stepflag][i];
	}
	pwmflag.stepflag++;
	if (pwmflag.stepflag >= 7)
	{
		pwmflag.stepflag = 0;
	}
}

void Robot_Forward(void) //前进------------F
{
	uint8_t i;
	for (i = 0; i < 18; i++)
	{
		tarpwm[i] = Forward[pwmflag.stepflag][i];
	}
	
	if (pwmflag.tarmodeflag != 'F')
	{
		if (pwmflag.stepflag == 9)
		{
			pwmflag.stepflag = 20;
			return;
		}
		else if (pwmflag.stepflag == 13)
		{
			pwmflag.stepflag = 14;
			return;
		}
	}
	else if(pwmflag.stepflag == 13)
	{
		pwmflag.stepflag = 6;
		return;
	}
	
	pwmflag.stepflag++;
	if (pwmflag.stepflag >= 26 || pwmflag.stepflag==20)
	{
		pwmflag.stepflag = 0;
	}
	
}

void Robot_Turnright(void) //右转------------R
{
	uint8_t i;
	
	for (i = 0; i < 18; i++)
	{
		tarpwm[i] = Turnright[pwmflag.stepflag][i];
	}
	
	if (pwmflag.tarmodeflag != 'R')
	{
		if (pwmflag.stepflag == 3)
		{
			pwmflag.stepflag = 7;
			return;
		}
		else if (pwmflag.stepflag == 6)
		{
			pwmflag.stepflag = 9;
			return;
		}
	}
	else if (pwmflag.stepflag == 6)
	{
		pwmflag.stepflag = 1;
		return;
	}

	pwmflag.stepflag++;
	if (pwmflag.stepflag >= 10 || pwmflag.stepflag == 8)
	{
		pwmflag.stepflag = 0;
	}
	
}

void Robot_Turnleft(void) //左转------------L
{
	uint8_t i;
	
	for (i = 0; i < 18; i++)
	{
		tarpwm[i] = Turnleft[pwmflag.stepflag][i];
	}
	
	if (pwmflag.tarmodeflag != 'R')
	{
		if (pwmflag.stepflag == 3)
		{
			pwmflag.stepflag = 7;
			return;
		}
		else if (pwmflag.stepflag == 6)
		{
			pwmflag.stepflag = 9;
			return;
		}
	}
	else if (pwmflag.stepflag == 6)
	{
		pwmflag.stepflag = 1;
		return;
	}

	pwmflag.stepflag++;
	if (pwmflag.stepflag >= 10 || pwmflag.stepflag == 8)
	{
		pwmflag.stepflag = 0;
	}
	
}



void Robot_Control(void)     //运动模式更新判断函数
{
	MassageData01 data;
	if ((pwmflag.tarmodeflag != pwmflag.modeflag)&&(pwmflag.stepflag == 0 || pwmflag.modeflag == 'A'))
	{
		
		if (pwmflag.modeflag == 'A')
		{
			pwmflag.modeflag = pwmflag.tarmodeflag;
			
		}
		else
		{
			pwmflag.modeflag = 'A';
			
		}
		data.flag = modeflag;
		data.variable = pwmflag.modeflag;
		osMessagePutQueue01(data);
		
		pwmflag.stepflag = 0;                  /////////
	}
	else if(pwmflag.modeflag=='A'&&pwmflag.stepflag != 0)
	{
		return;
	}
	switch (pwmflag.modeflag)
	{
	case 'A' :Robot_Stand();   break;
	case 'B' :Robot_Test();      break;
	case 'C' :Robot_Down(); break;
	case 'F' : Robot_Forward(); break;
	case 'R' : Robot_Turnright(); break;
	case 'L' : Robot_Turnleft(); break;
		
	default:pwmflag.tarmodeflag = 'A'; break;
	}
	data.flag = stepflag;
	data.variable = pwmflag.stepflag;
	osMessagePutQueue01(data);
}
void Set_PWM(uint32_t num, uint32_t off)
{
	if (off > 512)         off = 512;     //限制0.5ms--2.5ms   满值4096
	else if (off < 102)  off = 102;
	
//	switch (num)
//	{
//	case 'A' :Robot_Stand(); break;
//	case 'B' :Robot_Test(); break;
//	case 'C' :Robot_Down(); break;
//	case 'F' : Robot_Forward(); break;
//	default:pwmflag.tarmodeflag = 'A'; break;
//	}
	
	if (num < 3)
	{
		SetPWM(PWM_Address_0, num, 0, off);
	}
	else if(num < 6)
	{
		SetPWM(PWM_Address_0, num+1, 0, off);
	}
	else if(num < 9)
	{
		SetPWM(PWM_Address_0, num+2, 0, off);
	}
	else if(num < 12)
	{
		SetPWM(PWM_Address_0, num+3, 0, off);
	}
	else if(num < 15)
	{
		SetPWM(PWM_Address_1, num-12, 0, off);
	}
	else if(num < 18)
	{
		SetPWM(PWM_Address_1, num-11, 0, off);
	}
	
//	if (num < 16)
//	{
//		
//	SetPWM(PWM_Address_0, num, 0, off);
//	}
//	else if(num < 18)
//	{
//		num = num - 16;
//	SetPWM(PWM_Address_1, num, 0, off);
//	}
	
}

void Calculate_Increment(void)								//舵机转动增量计算函数--已更新过tarpwm后
{	
	uint8_t i;
	for (i = 0; i < 18; i++)
	{
		incpwm[i] = (tarpwm[i] - pwm[i]) / 10.0;//////////////////////
		lpwm[i] = pwm[i];
		ltarpwm[i] = tarpwm[i];
	}
	pwmflag.countflag = 0;
}
void servo_PWMData(void)    //执行PWM数据,,需要定时循环调用
{
	uint8_t i;
			
	if (pwmflag.countflag < 9)////////////////////
		{
			pwmflag.countflag++;
			for (i = 0; i < 18; i++)
			{
				if (pwm[i] != ltarpwm[i])
				{
					pwm[i] = (uint16_t)(lpwm[i] + (pwmflag.countflag + 1)*incpwm[i]);
					Set_PWM(i, pwm[i]);
				}
			}
		}
		else
		{	
			for (i = 0; i < 18; i++)
			{
				incpwm[i] = 0;
				if (pwm[i] != ltarpwm[i])
				{
					pwm[i] = ltarpwm[i];
					
					Set_PWM(i, pwm[i]);
				}
			}	
			
			Robot_Control();     //运动模式更新判断函数
			
			Calculate_Increment();   //舵机转动增量计算函数--已更新过tarpwm后
		}
	
	
}